From: Laine Stump <laine@redhat.com>
Date: Mon, 28 Mar 2011 08:00:00 -0500
Subject: Make libnl port allocation/deallocation threadsafe and correct

This patch resolves the following two libnl-1.1 bugs:

  https://bugzilla.redhat.com/show_bug.cgi?id=677724
  https://bugzilla.redhat.com/show_bug.cgi?id=677725

Description:

generate_local_port/release_local_port could be called by multiple
threads at the same time, which could leave multiple threads using the
same port. This is now protected against with a lock around access to
used_ports_map.

Additionally (and probably more significantly), the logic for
determining the bit to clear when releasing a local port was seriously
flawed. This patch also fixed that problem.

---
diff -rupN libnl-1.1.orig/lib/Makefile libnl-1.1.new/lib/Makefile
--- libnl-1.1.orig/lib/Makefile	2011-03-27 22:55:39.609231496 -0400
+++ libnl-1.1.new/lib/Makefile	2011-03-27 23:06:38.731637497 -0400
@@ -48,7 +48,7 @@ all:
 	$(MAKE) $(OUT_AR)
 
 $(OUT_SLIB): ../Makefile.opts $(OBJ)
-	$(CC) -shared -Wl,-soname,libnl.so.1 -o $(OUT_SLIB) $(OBJ) $(LIBNL_LIB) -lc
+	$(CC) -shared -Wl,-soname,libnl.so.1 -o $(OUT_SLIB) $(OBJ) $(LIBNL_LIB) -lc -lpthread
 	rm -f $(LN1_SLIB) ; $(LN) -s $(OUT_SLIB) $(LN1_SLIB)
 	rm -f $(LN_SLIB) ; $(LN) -s $(LN1_SLIB) $(LN_SLIB)
 
diff -rupN libnl-1.1.orig/lib/socket.c libnl-1.1.new/lib/socket.c
--- libnl-1.1.orig/lib/socket.c	2008-01-14 10:48:45.000000000 -0500
+++ libnl-1.1.new/lib/socket.c	2011-03-27 23:14:50.373800495 -0400
@@ -89,6 +89,8 @@
  * @{
  */
 
+#include <pthread.h>
+
 #include <netlink-local.h>
 #include <netlink/netlink.h>
 #include <netlink/utils.h>
@@ -117,12 +119,15 @@ static void __init init_default_cb(void)
 }
 
 static uint32_t used_ports_map[32];
+static pthread_mutex_t port_map_mutex = PTHREAD_MUTEX_INITIALIZER;
 
 static uint32_t generate_local_port(void)
 {
 	int i, n;
 	uint32_t pid = getpid() & 0x3FFFFF;
 
+	pthread_mutex_lock(&port_map_mutex);
+
 	for (i = 0; i < 32; i++) {
 		if (used_ports_map[i] == 0xFFFFFFFF)
 			continue;
@@ -136,11 +141,15 @@ static uint32_t generate_local_port(void
 
 			/* PID_MAX_LIMIT is currently at 2^22, leaving 10 bit
 			 * to, i.e. 1024 unique ports per application. */
-			return pid + (n << 22);
 
+			pthread_mutex_unlock(&port_map_mutex);
+
+			return pid + (n << 22);
 		}
 	}
 
+	pthread_mutex_unlock(&port_map_mutex);
+
 	/* Out of sockets in our own PID namespace, what to do? FIXME */
 	return UINT_MAX;
 }
@@ -153,7 +162,10 @@ static void release_local_port(uint32_t 
 		return;
 	
 	nr = port >> 22;
-	used_ports_map[nr / 32] &= ~((nr % 32) + 1);
+
+	pthread_mutex_lock(&port_map_mutex);
+	used_ports_map[nr / 32] &= ~(1 << (nr % 32));
+	pthread_mutex_unlock(&port_map_mutex);
 }
 
 /**
